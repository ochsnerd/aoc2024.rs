use crate::graph::dijkstra;

pub fn solve(_: &str) -> (usize, usize) {
    (
        to_usize_digits(&execute1(17323786)),
        inverse(&[2, 4, 1, 1, 7, 5, 1, 5, 4, 1, 5, 5, 0, 3, 3, 0]),
    )
}

// by hand,
fn execute1(mut a: usize) -> Vec<u8> {
    let m = 0b111; // for mod 8
    let mut res = vec![];
    // Note: this loop will run ~ a.log2() / 3 times, producing one digit per iteration.
    // This tells us the range of a we need to search for the fixed-point
    while a != 0 {
        let b = a & m ^ 1;
        // because of this look-ahead, later digits influence earlier digits.
        let c = (a >> b) & m;
        res.push((b ^ c ^ 5) as u8);
        a >>= 3;
    }
    res.reverse();
    res
}

#[allow(dead_code)]
fn execute2(a: usize) -> Vec<u8> {
    let d = to_binary_digits(a);
    let get_3_bits_starting_at = |i| to_usize_binary(d.get(i..i + 3).unwrap_or(&[]));

    (0..d.len())
        .step_by(3)
        .map(|i| {
            let shift = 1 ^ get_3_bits_starting_at(i);
            let lookahead = get_3_bits_starting_at(i + shift);
            (shift ^ lookahead ^ 5) as u8
        })
        .rev()
        .collect()
}

#[allow(dead_code)]
fn execute3(a: usize) -> Vec<u8> {
    (0..(to_binary_digits(a).len() as f32 / 3.0).ceil() as usize)
        .map(|i| {
            let i = i * 3;
            let shift = 1 ^ get_3_bits_starting_at(a, i);
            let lookahead = get_3_bits_starting_at(a, i + shift);
            (shift ^ lookahead ^ 5) as u8
        })
        .rev()
        .collect()
}

fn get_3_bits_starting_at(v: usize, i: usize) -> usize {
    (v >> i) & 0b111
}

fn replace_3_bits_starting_at(v: usize, i: usize, chunk: usize) -> usize {
    let mask = 0b111 << i;
    (v & !mask) | ((chunk & 0b111) << i)
}

// more like some pseudo-inverse because `execute` is not injective
fn inverse(r: &[u8]) -> usize {
    // strategy: build `a` in reverse
    // Because of the look-ahead, the value of the current digit of the output could
    // be generated by different values of the current digit of the input.
    // Solution: Explore all possible values; use Dijkstra for that.
    // Could also be done (possibly simpler) by doing a DFS and looking at all possible
    // solutions (or being careful about the order of traversal)

    fn get_next_possible_a_values(
        a_curr: usize,
        j: usize,
        target: u8,
    ) -> impl Iterator<Item = usize> {
        (0..=0b111).filter_map(move |maybe_chunk| {
            let a = replace_3_bits_starting_at(a_curr, j, maybe_chunk);
            let shift = 1 ^ get_3_bits_starting_at(a, j);
            let lookahead = get_3_bits_starting_at(a, j + shift);
            if shift ^ lookahead ^ 5 == target as usize {
                Some(a)
            } else {
                None
            }
        })
    }

    dijkstra(
        // Node: (Option<index into `r`>, `a` so far)
        // If Node.0.is_none() we're done
        (Some(r.len() - 1), 0usize),
        |n| {
            if let (Some(i), a) = *n {
                get_next_possible_a_values(a, i * 3, r[i])
                    // want smallest a, so we set a as edge-weight
                    .map(|a| (a, (i.checked_sub(1), a)))
                    .collect::<Vec<_>>()
            } else {
                vec![]
            }
        },
        |&n| n.0.is_none(),
    )
    .map(|s| s.last().unwrap().1)
    .expect("No inverse found!")
}

// lsb
fn to_usize_binary(x: &[bool]) -> usize {
    x.iter().enumerate().map(|(i, &v)| (v as usize) << i).sum()
}

fn to_usize_digits(x: &[u8]) -> usize {
    x.iter()
        .enumerate()
        .map(|(i, &v)| v as usize * 10usize.pow(i as u32))
        .sum()
}

// lsb
fn to_binary_digits(mut x: usize) -> Vec<bool> {
    let mut result = vec![];
    while x > 0 {
        result.push((x & 1) == 1);
        x >>= 1;
    }
    result
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_replace_and_read_3_bits() {
        let original = 0b11111111;
        let new_chunk = 0b000;
        let modified = replace_3_bits_starting_at(original, 3, new_chunk);
        let read_back = get_3_bits_starting_at(modified, 3);

        assert_eq!(read_back, new_chunk);
        assert_eq!(modified, 0b11000111);
    }

    #[test]
    fn test_executes() {
        let a = 17323786;
        assert_eq!(execute1(a), execute2(a));
        assert_eq!(execute1(a), execute3(a));
    }

    #[test]
    fn test_roundtrip() {
        for n in 0..100 {
            let binary = to_binary_digits(n);
            let result = to_usize_binary(&binary);
            assert_eq!(result, n, "Roundtrip failed for {}", n);
        }
    }
}
